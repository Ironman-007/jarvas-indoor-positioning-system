{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-mkdocs",
            "text": "For full documentation visit  mkdocs.org .",
            "title": "Welcome to MkDocs"
        },
        {
            "location": "/#commands",
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.",
            "title": "Commands"
        },
        {
            "location": "/#project-layout",
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Project layout"
        },
        {
            "location": "/hardware/",
            "text": "JARVAS Hardware\n\n\nThe core of the JARVAS system is the DWM1000 (\n\nproduct page\n,\n\ndatasheet\n\n) radio module, an ultra wideband transciever module optimized for time of\nflight ranging systems, and the Atmega32U4 processor.\n\n\nThere are two versions of the JARVAS hardware: a base station board that\nsupports WiFi (using an\n\nESP8266\n\n) and is designed for easy debugging, and a small, low-cost tag module.\nThe system requires at least one of the anchors have WiFi support so transmit\nlocation data to a server, however all other anchors and tags in the system\nmay use either the larger base station board or the small tag board.\n\n\nThe Tag\n\n\n\n\nThe tag board hosts an Atmega32U4, a single-cell LiPo/Li-Ion connector, a few\ndebugging LEDs, and the DWM1000 radio module. It is essentially a\npurpose-built version of the popular \nSparkFun Pro Micro\n\nor the \nAdafruit Atmega32U4 breakout\n\nwith a DWM1000 module built in.\n\n\nIn total, it measures 1.5\"x0.9\" without the programming tag.\n\n\nNote that while we call this this \"tag\", it is completely capable of being\nused as an anchor as well, provided that there is at least one anchor in the\nsystem which supports WiFi.\n\n\nProgramming Header\n\n\n\n\nThe tag comes with a break-away section for initial programming. The\nsection at the top contains test points for the 3.3 V and GND rails and an\nICSP header. This ICSP header can be used to program the Atmega32U4. If you\nchoose to install the Arduino firmware, as described \nhere\n,\nyou can program this board directly over USB through the Arduino software.\nOnce you verify that everythings is working, this top section can be broken\noff to reduce the size and height of the PCB.\n\n\n\n\nThe Anchor\n\n\n\n\nThe anchor is the larger, more debug-friendly, and WiFi-supporting version.\nIt is extremely similar to the tag except for the addition of an ESP8266 WiFi\nModule and using an off-the-shelf Arduino Pro Micro instead of having an\nAtmega32U4 on-board. This means that no programmer is required to get this\nboard up and running. The downside, though, is that it is significantly larger\nand costs more.",
            "title": "Hardware"
        },
        {
            "location": "/hardware/#jarvas-hardware",
            "text": "The core of the JARVAS system is the DWM1000 ( product page , datasheet \n) radio module, an ultra wideband transciever module optimized for time of\nflight ranging systems, and the Atmega32U4 processor.  There are two versions of the JARVAS hardware: a base station board that\nsupports WiFi (using an ESP8266 \n) and is designed for easy debugging, and a small, low-cost tag module.\nThe system requires at least one of the anchors have WiFi support so transmit\nlocation data to a server, however all other anchors and tags in the system\nmay use either the larger base station board or the small tag board.",
            "title": "JARVAS Hardware"
        },
        {
            "location": "/hardware/#the-tag",
            "text": "The tag board hosts an Atmega32U4, a single-cell LiPo/Li-Ion connector, a few\ndebugging LEDs, and the DWM1000 radio module. It is essentially a\npurpose-built version of the popular  SparkFun Pro Micro \nor the  Adafruit Atmega32U4 breakout \nwith a DWM1000 module built in.  In total, it measures 1.5\"x0.9\" without the programming tag.  Note that while we call this this \"tag\", it is completely capable of being\nused as an anchor as well, provided that there is at least one anchor in the\nsystem which supports WiFi.  Programming Header   The tag comes with a break-away section for initial programming. The\nsection at the top contains test points for the 3.3 V and GND rails and an\nICSP header. This ICSP header can be used to program the Atmega32U4. If you\nchoose to install the Arduino firmware, as described  here ,\nyou can program this board directly over USB through the Arduino software.\nOnce you verify that everythings is working, this top section can be broken\noff to reduce the size and height of the PCB.",
            "title": "The Tag"
        },
        {
            "location": "/hardware/#the-anchor",
            "text": "The anchor is the larger, more debug-friendly, and WiFi-supporting version.\nIt is extremely similar to the tag except for the addition of an ESP8266 WiFi\nModule and using an off-the-shelf Arduino Pro Micro instead of having an\nAtmega32U4 on-board. This means that no programmer is required to get this\nboard up and running. The downside, though, is that it is significantly larger\nand costs more.",
            "title": "The Anchor"
        },
        {
            "location": "/localization/",
            "text": "Localization\n\n\nJARVAS estimates your position using a linear least squares algorithm based\non time of flight ranging data. On this page, we will break down how this\nworks in detail.\n\n\nImagine you are on a ship and can see a single lighthouse in the distance. \nLet's say you can tell the distance to this lighthouse but nothing else.\nIf you were looking at a map and knew the location of the lighthouse, you\ncould draw a circle around the lighthouse and know that you were somewhere\nalong the circle.\n\n\nNow let's say you can see a second lighthouse and also your know distance to \nit (but not, let's pretend, the angle between the two lighthouses). Now you\nhave two circles you can draw. Assuming the two lighthouses are in different\nlocations, the circles will overlap in one or two locations. Finally, by\nadding a third lighthouse, you can figure out which point you are at.\n\n\n\n\nDerived from image by pixelbuddha [CC BY 3.0 (http://creativecommons.org/licenses/by/3.0)], via Wikimedia Commons\n\n\nLinear Least Squares Estimation\n\n\nIf you aren't familiar with linear least squares estimation, we recommend some\nbackground reading before jumping into this:\n\n\nWikipedia: Linear Least Squares\n\n\nStanford Linear Algebra Course Notes\n\n\nOur linearized technique is based on the first method described in \n\"Linear least squares localization in sensor networks\" by Yue Wang (DOI: \n\n10.1186/s13638-015-0298-1\n).\n\n\nIn general, localization based on a set of distances in a non-linear problem,\nhowever there are linear approximtaions that work quite well.\n\n\nEach anchor has some known position \n(x_i,y_i\n and is can measure a distance\n\n\\hat{d_i}\n to the tag. For a single anchor \ni\n ranging to a tag at\nposition \n(x,y)\n, this\ngives us the simple geometric equation:\n\n\n\n\n (x-x_i)^2+(y-y_i)^2=d_i^2 \n\n\n\n\nWe can then re-arrange this expression as follows:\n\n\n\n\n x^2-2xx_i+x_i^2+y^2-2yy_i+y_i^2=\\hat{d}_i^2 \\\\\n-2xx_i - 2yy_i + (x^2+y^2) = \\hat{d}_i^2 - x_i^2 - y_i^2 \n\n\n\n\nWe have three (or more) anchors, so we can write at least three of these\nequations. Written in matrix form, we have:\n\n\n\n\n\n\\begin{bmatrix}\n-2x_1 & -2y_1 & 1 \\\\\n-2x_2 & -2y_2 & 1 \\\\\n-2x_3 & -2y_3 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\nx^2 + y^2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\hat{d}_1^2-x_1^2-y_1^2 \\\\\n\\hat{d}_2^2-x_2^2-y_2^2 \\\\\n\\hat{d}_3^2-x_3^2-y_3^2\n\\end{bmatrix}\n\n\n\n\n\nThis gives us the standard form:\n\n\n\n\n\n\\begin{bmatrix}\nx \\\\\ny \\\\\nx^2 + y^2\n\\end{bmatrix}_{ls}\n=\n\\begin{bmatrix}\n-2x_1 & -2y_1 & 1 \\\\\n-2x_2 & -2y_2 & 1 \\\\\n-2x_3 & -2y_3 & 1\n\\end{bmatrix}^\\dagger\n\\begin{bmatrix}\n\\hat{d}_1^2-x_1^2-y_1^2 \\\\\n\\hat{d}_2^2-x_2^2-y_2^2 \\\\\n\\hat{d}_3^2-x_3^2-y_3^2\n\\end{bmatrix}\n\n\n\n\n\nThe left side of the equation is what we want to solve for. Specifically, we are interested in the first two terms of the vector: \nx\n and \ny\n.\n\n\nOn the right, the large matrix that we have to take the \n\npseudo-inverse\n\nof is a function only of the configuration of the system. It changes only if the anchors move, not if the tag moves. This is very important because taking the pseudo-inverse requires a non-trivial number of computations, especially as you start adding more anchors.\n\n\nAt runtime, this works out to be a single matrix-vector multiplication of a 3x3 by a 3x1.\n\n\nMATLAB Implementation\n\n\n\n\nIn order to test this algorith, we created a MATLAB script that takes in a set of positions and ranges and outputs a graph of the real and estimated location of the tag. If you are intersted in extending this project to use any of several possible better linearized algorithms, this MATLAB script would be a good starting point.\n\n\nYou can find the two MATLAB files \nrangepositioning.m\n and \nplotposition.m\n in the \nsimulation folder\n of our repository.\n\n\nC Implementation\n\n\nIn the JARVAS system, this processing is run on the tag iself. The C implementaiton of this algorithm uses the Arduino MatrixMath library and lives in the \ntag sketch\n.",
            "title": "Localization Algorithm"
        },
        {
            "location": "/localization/#localization",
            "text": "JARVAS estimates your position using a linear least squares algorithm based\non time of flight ranging data. On this page, we will break down how this\nworks in detail.  Imagine you are on a ship and can see a single lighthouse in the distance. \nLet's say you can tell the distance to this lighthouse but nothing else.\nIf you were looking at a map and knew the location of the lighthouse, you\ncould draw a circle around the lighthouse and know that you were somewhere\nalong the circle.  Now let's say you can see a second lighthouse and also your know distance to \nit (but not, let's pretend, the angle between the two lighthouses). Now you\nhave two circles you can draw. Assuming the two lighthouses are in different\nlocations, the circles will overlap in one or two locations. Finally, by\nadding a third lighthouse, you can figure out which point you are at.   Derived from image by pixelbuddha [CC BY 3.0 (http://creativecommons.org/licenses/by/3.0)], via Wikimedia Commons",
            "title": "Localization"
        },
        {
            "location": "/localization/#linear-least-squares-estimation",
            "text": "If you aren't familiar with linear least squares estimation, we recommend some\nbackground reading before jumping into this:  Wikipedia: Linear Least Squares  Stanford Linear Algebra Course Notes  Our linearized technique is based on the first method described in \n\"Linear least squares localization in sensor networks\" by Yue Wang (DOI:  10.1186/s13638-015-0298-1 ).  In general, localization based on a set of distances in a non-linear problem,\nhowever there are linear approximtaions that work quite well.  Each anchor has some known position  (x_i,y_i  and is can measure a distance \\hat{d_i}  to the tag. For a single anchor  i  ranging to a tag at\nposition  (x,y) , this\ngives us the simple geometric equation:    (x-x_i)^2+(y-y_i)^2=d_i^2    We can then re-arrange this expression as follows:    x^2-2xx_i+x_i^2+y^2-2yy_i+y_i^2=\\hat{d}_i^2 \\\\\n-2xx_i - 2yy_i + (x^2+y^2) = \\hat{d}_i^2 - x_i^2 - y_i^2    We have three (or more) anchors, so we can write at least three of these\nequations. Written in matrix form, we have:   \n\\begin{bmatrix}\n-2x_1 & -2y_1 & 1 \\\\\n-2x_2 & -2y_2 & 1 \\\\\n-2x_3 & -2y_3 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\nx^2 + y^2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\hat{d}_1^2-x_1^2-y_1^2 \\\\\n\\hat{d}_2^2-x_2^2-y_2^2 \\\\\n\\hat{d}_3^2-x_3^2-y_3^2\n\\end{bmatrix}   This gives us the standard form:   \n\\begin{bmatrix}\nx \\\\\ny \\\\\nx^2 + y^2\n\\end{bmatrix}_{ls}\n=\n\\begin{bmatrix}\n-2x_1 & -2y_1 & 1 \\\\\n-2x_2 & -2y_2 & 1 \\\\\n-2x_3 & -2y_3 & 1\n\\end{bmatrix}^\\dagger\n\\begin{bmatrix}\n\\hat{d}_1^2-x_1^2-y_1^2 \\\\\n\\hat{d}_2^2-x_2^2-y_2^2 \\\\\n\\hat{d}_3^2-x_3^2-y_3^2\n\\end{bmatrix}   The left side of the equation is what we want to solve for. Specifically, we are interested in the first two terms of the vector:  x  and  y .  On the right, the large matrix that we have to take the  pseudo-inverse \nof is a function only of the configuration of the system. It changes only if the anchors move, not if the tag moves. This is very important because taking the pseudo-inverse requires a non-trivial number of computations, especially as you start adding more anchors.  At runtime, this works out to be a single matrix-vector multiplication of a 3x3 by a 3x1.",
            "title": "Linear Least Squares Estimation"
        },
        {
            "location": "/localization/#matlab-implementation",
            "text": "In order to test this algorith, we created a MATLAB script that takes in a set of positions and ranges and outputs a graph of the real and estimated location of the tag. If you are intersted in extending this project to use any of several possible better linearized algorithms, this MATLAB script would be a good starting point.  You can find the two MATLAB files  rangepositioning.m  and  plotposition.m  in the  simulation folder  of our repository.",
            "title": "MATLAB Implementation"
        },
        {
            "location": "/localization/#c-implementation",
            "text": "In the JARVAS system, this processing is run on the tag iself. The C implementaiton of this algorithm uses the Arduino MatrixMath library and lives in the  tag sketch .",
            "title": "C Implementation"
        },
        {
            "location": "/filtering/",
            "text": "Filtering\n\n\nIn our testing, we found the ranging data to be quite noisy. With only three anchors, the linear least squares algorithm is quite noise sensitive. As such, some filtering on the ranging data is necessary.\n\n\nThe \nArduino DWM1000 library\n by thotro has a built-in (exponential moving average](https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average) filter that can be enabled with a single call to \nDW1000Ranging.useRangeFilter(true);\n. This is a very computationally low-cost choice and definitely a good place to start.\n\n\nEarly on, we took some raw data from pairs of DWM1000 modules in various locations. An example of this data is below:\n\n\n\n\nAs you can see, the noise is dominated by sharp peaks lasting only a sample or two. For this type of noise, a median filter is often a more effective choice. While any kind of moving average filter is always going to be affected at least a little by an extremely out of range value, a median filter will allow such valus to slide through without changing output.\n\n\nShown below are the results of a simple median filter overlayed in red against another raw data set in black.\n\n\n \"Median filtered data\")",
            "title": "Filtering"
        },
        {
            "location": "/filtering/#filtering",
            "text": "In our testing, we found the ranging data to be quite noisy. With only three anchors, the linear least squares algorithm is quite noise sensitive. As such, some filtering on the ranging data is necessary.  The  Arduino DWM1000 library  by thotro has a built-in (exponential moving average](https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average) filter that can be enabled with a single call to  DW1000Ranging.useRangeFilter(true); . This is a very computationally low-cost choice and definitely a good place to start.  Early on, we took some raw data from pairs of DWM1000 modules in various locations. An example of this data is below:   As you can see, the noise is dominated by sharp peaks lasting only a sample or two. For this type of noise, a median filter is often a more effective choice. While any kind of moving average filter is always going to be affected at least a little by an extremely out of range value, a median filter will allow such valus to slide through without changing output.  Shown below are the results of a simple median filter overlayed in red against another raw data set in black.   \"Median filtered data\")",
            "title": "Filtering"
        }
    ]
}